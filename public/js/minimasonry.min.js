class MiniMasonry {
  constructor(conf) {
    this._sizes = []
    this._colSizes = []
    this._columns = []
    this._container = null
    this._count = null
    this._prevCount = null
    this._width = 0
    this._colWidth = 0
    this._removeListener = null
    this._currentGutterX = null
    this._currentGutterY = null
    this._images = null
    this._children = null
    this._startX = 0
    ;(this._resizeTimeout = null),
      (this.conf = {
        baseWidth: 255,
        gutterX: null,
        gutterY: null,
        gutter: 10,
        container: null,
        minify: true,
        ultimateGutter: 15,
        surroundingGutter: true,
        direction: 'ltr',
        wedge: false,
        images: null,
      })

    this.init(conf)
  }

  async init(conf) {
    for (let i in this.conf) {
      if (conf[i] != undefined) {
        this.conf[i] = conf[i]
      }
    }

    if (this.conf.gutterX == null || this.conf.gutterY == null) {
      this.conf.gutterX = this.conf.gutterY = this.conf.gutter
    }
    this._currentGutterX = this.conf.gutterX
    this._currentGutterY = this.conf.gutterY

    this._container =
      typeof this.conf.container == 'object' && this.conf.container.nodeName
        ? this.conf.container
        : document.querySelector(this.conf.container)
    this._images =
      typeof this.conf.images == 'object' && this.conf.images[0].nodeName
        ? this.conf.images
        : document.querySelectorAll(this.conf.images)

    if (!this._container) {
      throw new Error('Container not found or missing')
    }

    let onResize = this.resizeThrottler.bind(this)
    window.addEventListener('resize', onResize)
    this._removeListener = function () {
      window.removeEventListener('resize', onResize)
      if (this._resizeTimeout != null) {
        window.clearTimeout(this._resizeTimeout)
        this._resizeTimeout = null
      }
    }

    this.reset(true)
    await this.loadImages()
    this.layout()
    return
  }

  reset(width) {
    this._sizes = []
    this._columns = []
    this._prevCount = this._count
    this._colWidth = null
    this._count = null
    this._children = null
    this._startX = 0
    if (width) this.resetWidth()

    if (this.getCount() == 1) {
      // Set ultimate gutter when only one column is displayed
      this._currentGutterX = this.conf.ultimateGutter
      // As gutters are reduced, two column may fit, forcing to 1
      this._count = 1
    } else if (this._width < this.conf.baseWidth + 2 * this._currentGutterX) {
      // Remove gutter when screen is to low
      this._currentGutterX = 0
    } else {
      this._currentGutterX = this.conf.gutterX
    }
  }

  resetWidth() {
    this._width = this._container.clientWidth
    let minWidth = this.conf.baseWidth
    if (this._width < minWidth) {
      this._width = minWidth
      this._container.style.minWidth = minWidth + 'px'
    }
    this._width = this._container.clientWidth
  }

  getCount() {
    if (this.conf.surroundingGutter) {
      return Math.floor(
        (this._width - this._currentGutterX) /
          (this.conf.baseWidth + this._currentGutterX)
      )
    }

    return Math.floor(
      (this._width + this._currentGutterX) /
        (this.conf.baseWidth + this._currentGutterX)
    )
  }

  computeWidth() {
    let width
    if (this.conf.surroundingGutter) {
      width =
        (this._width - this._currentGutterX) / this._count -
        this._currentGutterX
    } else {
      width =
        (this._width + this._currentGutterX) / this._count -
        this._currentGutterX
    }
    width = Number.parseFloat(width.toFixed(2))

    return width
  }

  layout() {
    if (!this._container) {
      console.error('Container not found')
      return
    }
    this.reset(true)

    //Computing columns count
    if (this._count == null) {
      this._count = this.getCount()
    }
    //Computing columns width
    this._colWidth = this.computeWidth()

    for (let i = 0; i < this._count; i++) {
      this._columns[i] = 0
    }

    //Saving children real heights
    this._children = this._container.children
    for (let k = 0; k < this._children.length; k++) {
      // Set colWidth before retrieving element height if content is proportional
      this._children[k].style.width = this._colWidth + 'px'
      this._children[k].firstElementChild.firstElementChild.style.width =
        this._colWidth + 'px'
      this._sizes[k] = this._children[k].clientHeight
      // adding height so we can transition it
      // children[k].style.height = this._sizes[k] + 'px'
    }

    if (this.conf.direction == 'ltr') {
      this._startX = this.conf.surroundingGutter ? this._currentGutterX : 0
    } else {
      this._startX =
        this._width - (this.conf.surroundingGutter ? this._currentGutterX : 0)
    }
    if (this._count > this._sizes.length) {
      //If more columns than children
      let occupiedSpace =
        this._sizes.length * (this._colWidth + this._currentGutterX) -
        this._currentGutterX
      if (this.conf.wedge === false) {
        if (this.conf.direction == 'ltr') {
          this._startX = (this._width - occupiedSpace) / 2
        } else {
          this._startX = this._width - (this._width - occupiedSpace) / 2
        }
      } else {
        if (this.conf.direction == 'ltr');
        else {
          this._startX = this._width - this._currentGutterX
        }
      }
    }

    if (this._prevCount !== null) {
      if (this._count !== this._prevCount) {
        document.addEventListener('readystatechange', this.computeChildren)
      } else this.computeChildren(true)
    } else this.computeChildren(true)
  }

  computeChildren(runFunction) {
    if (document.readyState === 'complete' || runFunction === true) {
      //Computing position of children
      for (let index = 0; index < this._children.length; index++) {
        let nextColumn = this.conf.minify
          ? this.getShortest()
          : this.getNextColumn(index)

        let childrenGutter = 0
        if (this.conf.surroundingGutter || nextColumn != this._columns.length) {
          childrenGutter = this._currentGutterX
        }
        let x
        if (this.conf.direction == 'ltr') {
          x = this._startX + (this._colWidth + childrenGutter) * nextColumn
        } else {
          x =
            this._startX -
            (this._colWidth + childrenGutter) * nextColumn -
            this._colWidth
        }
        let y = this._columns[nextColumn]

        this._children[index].style.transform =
          'translate3d(' + Math.round(x) + 'px,' + Math.round(y) + 'px,0)'

        this._children[index].dataset.col = nextColumn

        this._columns[nextColumn] +=
          this._sizes[index] +
          (this._count > 1 ? this.conf.gutterY : this.conf.ultimateGutter) //margin-bottom
      }

      this._container.style.height =
        this._columns[this.getLongest()] - this._currentGutterY + 'px'
    }

    document.removeEventListener('readystatechange', this.computeChildren)
  }

  layoutCol(elem) {
    if (!this._container) {
      console.error('Container not found')
      return
    }
    this.reset()

    //Computing columns count
    if (this._count == null) {
      this._count = this.getCount()
    }

    //Computing columns width
    let colWidth = this.computeWidth()

    this._columns[0] = 0

    //Saving children real heights
    let children = this.getNextColumnSiblings(elem)
    let columnChildren = this.getColumn(elem.dataset.col)
    let childCount = this._container.childElementCount

    for (let k = 0; k < columnChildren.length; k++) {
      this._colSizes[k] = columnChildren[k].clientHeight
    }

    let startX
    if (this.conf.direction == 'ltr') {
      startX = this.conf.surroundingGutter ? this._currentGutterX : 0
    } else {
      startX =
        this._width - (this.conf.surroundingGutter ? this._currentGutterX : 0)
    }

    if (this._count > childCount) {
      //If more columns than children
      let occupiedSpace =
        childCount * (colWidth + this._currentGutterX) - this._currentGutterX
      if (this.conf.wedge === false) {
        if (this.conf.direction == 'ltr') {
          startX = (this._width - occupiedSpace) / 2
        } else {
          startX = this._width - (this._width - occupiedSpace) / 2
        }
      } else {
        if (this.conf.direction == 'ltr');
        else {
          startX = this._width - this._currentGutterX
        }
      }
    }

    //Computing position of children
    for (let index = 0; index < columnChildren.length; index++) {
      if (index < columnChildren.length - children.length) {
        this._columns[0] +=
          this._colSizes[index] +
          (this._count > 1 ? this.conf.gutterY : this.conf.ultimateGutter) //margin-bottom
      } else {
        let nextColumn = parseInt(elem.dataset.col)

        let childrenGutter = 0
        if (this.conf.surroundingGutter || nextColumn != this._count) {
          childrenGutter = this._currentGutterX
        }

        let x
        if (this.conf.direction == 'ltr') {
          x = startX + (colWidth + childrenGutter) * nextColumn
        } else {
          x = startX - (colWidth + childrenGutter) * nextColumn - colWidth
        }

        let y = this._columns[0]

        columnChildren[index].style.transform =
          'translate3d(' + Math.round(x) + 'px,' + Math.round(y) + 'px,0)'

        this._columns[0] +=
          this._colSizes[index] +
          (this._count > 1 ? this.conf.gutterY : this.conf.ultimateGutter) //margin-bottom
      }
    }
  }

  getNextColumnSiblings(elem) {
    // getting all sibling elements with same dataset col value
    let sibs = [elem]
    const col = parseInt(elem.dataset.col)

    while ((elem = elem.nextElementSibling)) {
      if (this.filter(elem, col)) sibs.push(elem)
    }

    return sibs
  }

  /**
   * Given a list of images to load and the dimensions of the viewport, calculates ideal image sizes and dynamically loads them in to the page
   * @param {nodeList} images list of images to be loaded
   * @returns {Void}
   */
  async loadImages() {
    const pixelRatio = window.devicePixelRatio || 1.0
    if (this._count == null) {
      this._count = this.getCount()
    }
    const colWidth = this.computeWidth()

    let str = `https://res.cloudinary.com/christianjosuebt/image/upload/q_auto,f_auto,fl_lossy,w_${Math.round(
      colWidth * pixelRatio
    )}/coffeeShops`

    const sources = Array.from(this._images).map(el => [
      el,
      `${str}/${el.dataset.src}`,
    ])

    return Promise.all(sources.map(this.loadImage)).then({
      msg: 'images have been loaded',
    })
  }

  // loads the images using promises
  loadImage(src) {
    return new Promise((resolve, reject) => {
      src[0].onload = () => resolve(src[0])
      src[0].onerror = reject
      src[0].src = src[1]
    })
  }

  getColumn(col) {
    // getting all sibling elements with same dataset col value
    return Array.from(this._container.querySelectorAll(`[data-col='${col}']`))
  }

  filter(elem, col) {
    if (elem.dataset && parseInt(elem.dataset.col) === col) {
      return true
    } else return false
  }

  getNextColumn(index) {
    return index % this._columns.length
  }

  getShortest() {
    let shortest = 0
    for (let i = 0; i < this._count; i++) {
      if (this._columns[i] < this._columns[shortest]) {
        shortest = i
      }
    }

    return shortest
  }

  getLongest() {
    let longest = 0
    for (let i = 0; i < this._count; i++) {
      if (this._columns[i] > this._columns[longest]) {
        longest = i
      }
    }

    return longest
  }

  resizeThrottler() {
    // ignore resize events as long as an actualResizeHandler execution is in the queue
    if (!this._resizeTimeout) {
      this._resizeTimeout = setTimeout(
        function () {
          this._resizeTimeout = null
          //IOS Safari throw random resize event on scroll, call layout only if size has changed
          if (this._container.clientWidth != this._width) {
            this.layout()
          }
          // The actualResizeHandler will execute at a rate of 30fps
        }.bind(this),
        33
      )
    }
  }

  destroy() {
    if (typeof this._removeListener == 'function') {
      this._removeListener()
    }

    let children = this._container.children
    for (let k = 0; k < children.length; k++) {
      children[k].removeAttribute('style')
      children[k].firstElementChild.firstElementChild.removeAttribute('style')
    }
    this._container?.removeAttribute('style')
  }
}
